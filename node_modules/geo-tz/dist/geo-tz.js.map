{"version":3,"file":"geo-tz.js","sources":["../src/oceanUtils.ts","../src/find.ts"],"sourcesContent":["type OceanZone = {\n  left: number\n  right: number\n  tzid: string\n}\n\nexport const oceanZones: OceanZone[] = [\n  { tzid: 'Etc/GMT-12', left: 172.5, right: 180 },\n  { tzid: 'Etc/GMT-11', left: 157.5, right: 172.5 },\n  { tzid: 'Etc/GMT-10', left: 142.5, right: 157.5 },\n  { tzid: 'Etc/GMT-9', left: 127.5, right: 142.5 },\n  { tzid: 'Etc/GMT-8', left: 112.5, right: 127.5 },\n  { tzid: 'Etc/GMT-7', left: 97.5, right: 112.5 },\n  { tzid: 'Etc/GMT-6', left: 82.5, right: 97.5 },\n  { tzid: 'Etc/GMT-5', left: 67.5, right: 82.5 },\n  { tzid: 'Etc/GMT-4', left: 52.5, right: 67.5 },\n  { tzid: 'Etc/GMT-3', left: 37.5, right: 52.5 },\n  { tzid: 'Etc/GMT-2', left: 22.5, right: 37.5 },\n  { tzid: 'Etc/GMT-1', left: 7.5, right: 22.5 },\n  { tzid: 'Etc/GMT', left: -7.5, right: 7.5 },\n  { tzid: 'Etc/GMT+1', left: -22.5, right: -7.5 },\n  { tzid: 'Etc/GMT+2', left: -37.5, right: -22.5 },\n  { tzid: 'Etc/GMT+3', left: -52.5, right: -37.5 },\n  { tzid: 'Etc/GMT+4', left: -67.5, right: -52.5 },\n  { tzid: 'Etc/GMT+5', left: -82.5, right: -67.5 },\n  { tzid: 'Etc/GMT+6', left: -97.5, right: -82.5 },\n  { tzid: 'Etc/GMT+7', left: -112.5, right: -97.5 },\n  { tzid: 'Etc/GMT+8', left: -127.5, right: -112.5 },\n  { tzid: 'Etc/GMT+9', left: -142.5, right: -127.5 },\n  { tzid: 'Etc/GMT+10', left: -157.5, right: -142.5 },\n  { tzid: 'Etc/GMT+11', left: -172.5, right: -157.5 },\n  { tzid: 'Etc/GMT+12', left: -180, right: -172.5 },\n]\n\n/**\n * Find the Etc/GMT* timezone name(s) corresponding to the given longitue.\n *\n * @param lon The longitude to analyze\n * @returns An array of strings of TZIDs\n */\nexport function getTimezoneAtSea(lon: number): string[] {\n  // coordinates along the 180 longitude should return two zones\n  if (lon === -180 || lon === 180) {\n    return ['Etc/GMT+12', 'Etc/GMT-12']\n  }\n  const tzs = []\n  for (let i = 0; i < oceanZones.length; i++) {\n    const z = oceanZones[i]\n    if (z.left <= lon && z.right >= lon) {\n      tzs.push(z.tzid)\n    } else if (z.right < lon) {\n      break\n    }\n  }\n  return tzs\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { decode } from 'geobuf'\nimport inside from '@turf/boolean-point-in-polygon'\nimport { point } from '@turf/helpers'\nimport Pbf from 'pbf'\n\nimport { getTimezoneAtSea, oceanZones } from './oceanUtils'\n\nconst tzData = require('../data/index.json')\n\nconst FEATURE_FILE_PATH = path.join(__dirname, '..', 'data', 'geo.dat')\nlet featureCache\n\ntype CacheOptions = {\n  /**\n   * If set to true, all features will be loaded into memory to shorten future lookup\n   * times.\n   */\n  preload?: boolean\n  /**\n   * Must be a map-like object with a `get` and `set` function.\n   */\n  store?: any\n}\n\n/**\n * Set caching behavior.\n *\n * @param {CacheOptions} options cachine options.\n */\nfunction cacheLevel(options?: CacheOptions) {\n  if (\n    options &&\n    options.store &&\n    typeof options.store.get === 'function' &&\n    typeof options.store.set === 'function'\n  ) {\n    featureCache = options.store\n  } else {\n    featureCache = new Map()\n  }\n  if (options && options.preload) {\n    const featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n\n    _preCache(featureFileFd)\n\n    fs.closeSync(featureFileFd)\n  }\n}\n\ncacheLevel()\n\n/**\n * A function that will load all features into an unexpiring cache\n *\n * @param {number} featureFileFd\n * @returns {void}\n */\nfunction _preCache(featureFileFd: number) {\n  // shoutout to github user @magwo for an initial version of this recursive function\n  function preloadFeaturesRecursive(curTzData, quadPos: string) {\n    if (curTzData.pos >= 0 && curTzData.len) {\n      const geoJson = loadFeatures(\n        quadPos,\n        curTzData.pos,\n        curTzData.len,\n        featureFileFd\n      )\n      featureCache.set(quadPos, geoJson)\n    } else if (typeof curTzData === 'object') {\n      Object.getOwnPropertyNames(curTzData).forEach(function (value) {\n        preloadFeaturesRecursive(curTzData[value], quadPos + value)\n      })\n    }\n  }\n  preloadFeaturesRecursive(tzData.lookup, '')\n}\n\n/**\n * Load features from geo.dat at offset pos with length len.\n * Optionally accept a file descriptor\n *\n * @param quadPos\n * @param pos\n * @param len\n * @param fd\n * @returns the GeoJSON features in within the given quad region as defined in the\n *  feature file data.\n */\nfunction loadFeatures(\n  quadPos: string,\n  pos: number,\n  len: number,\n  fd: number = -1\n) {\n  let featureFileFd = fd\n  if (featureFileFd < 0) {\n    featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n  }\n\n  // exact boundaries saved in file\n  // parse geojson for exact boundaries\n  const buf = Buffer.alloc(len)\n  const bytesRead = fs.readSync(featureFileFd, buf, 0, len, pos)\n\n  // close featureFileFd if we opened it\n  if (fd < 0) {\n    fs.closeSync(featureFileFd)\n  }\n\n  if (bytesRead < len) {\n    throw new Error(\n      `tried to read ${len} bytes from geo.dat but only got ${bytesRead} bytes`\n    )\n  }\n\n  const data = new Pbf(buf)\n  return decode(data)\n}\n\n/**\n * Find the timezone ID(s) at the given GPS coordinates.\n *\n * @param lat latitude (must be >= -90 and <=90)\n * @param lon longitue (must be >= -180 and <=180)\n * @returns An array of string of TZIDs at the given coordinate.\n */\nexport function find(lat: number, lon: number): string[] {\n  const originalLon = lon\n\n  let err\n\n  // validate latitude\n  if (isNaN(lat) || lat > 90 || lat < -90) {\n    err = new Error('Invalid latitude: ' + lat)\n    throw err\n  }\n\n  // validate longitude\n  if (isNaN(lon) || lon > 180 || lon < -180) {\n    err = new Error('Invalid longitude: ' + lon)\n    throw err\n  }\n\n  // North Pole should return all ocean zones\n  if (lat === 90) {\n    return oceanZones.map((zone) => zone.tzid)\n  }\n\n  // fix edges of the world\n  if (lat >= 89.9999) {\n    lat = 89.9999\n  } else if (lat <= -89.9999) {\n    lat = -89.9999\n  }\n\n  if (lon >= 179.9999) {\n    lon = 179.9999\n  } else if (lon <= -179.9999) {\n    lon = -179.9999\n  }\n\n  const pt = point([lon, lat])\n  const quadData = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0,\n  }\n  let quadPos = ''\n  let curTzData = tzData.lookup\n\n  while (true) {\n    // calculate next quadtree position\n    let nextQuad\n    if (lat >= quadData.midLat && lon >= quadData.midLon) {\n      nextQuad = 'a'\n      quadData.bottom = quadData.midLat\n      quadData.left = quadData.midLon\n    } else if (lat >= quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'b'\n      quadData.bottom = quadData.midLat\n      quadData.right = quadData.midLon\n    } else if (lat < quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'c'\n      quadData.top = quadData.midLat\n      quadData.right = quadData.midLon\n    } else {\n      nextQuad = 'd'\n      quadData.top = quadData.midLat\n      quadData.left = quadData.midLon\n    }\n\n    // console.log(nextQuad)\n    curTzData = curTzData[nextQuad]\n    // console.log()\n    quadPos += nextQuad\n\n    // analyze result of current depth\n    if (!curTzData) {\n      // no timezone in this quad, therefore must be timezone at sea\n      return getTimezoneAtSea(originalLon)\n    } else if (curTzData.pos >= 0 && curTzData.len) {\n      // get exact boundaries\n      let geoJson = featureCache.get(quadPos)\n      if (!geoJson) {\n        geoJson = loadFeatures(quadPos, curTzData.pos, curTzData.len)\n        featureCache.set(quadPos, geoJson)\n      }\n\n      const timezonesContainingPoint = []\n\n      for (let i = 0; i < geoJson.features.length; i++) {\n        if (inside(pt, geoJson.features[i])) {\n          timezonesContainingPoint.push(geoJson.features[i].properties.tzid)\n        }\n      }\n\n      // if at least one timezone contained the point, return those timezones,\n      // otherwise must be timezone at sea\n      return timezonesContainingPoint.length > 0\n        ? timezonesContainingPoint\n        : getTimezoneAtSea(originalLon)\n    } else if (curTzData.length > 0) {\n      // exact match found\n      return curTzData.map((idx) => tzData.timezones[idx])\n    } else if (typeof curTzData !== 'object') {\n      // not another nested quad index, throw error\n      err = new Error('Unexpected data type')\n      throw err\n    }\n\n    // calculate next quadtree depth data\n    quadData.midLat = (quadData.top + quadData.bottom) / 2\n    quadData.midLon = (quadData.left + quadData.right) / 2\n  }\n}\n\nexport { cacheLevel as setCache }\n\n/**\n * Load all features into memory to speed up future lookups.\n */\nexport function preCache() {\n  cacheLevel({ preload: true })\n}\n"],"names":["oceanZones","tzid","left","right","lon","tzs","i","length","z","push","featureCache","tzData","require","FEATURE_FILE_PATH","path","join","__dirname","cacheLevel","options","store","get","set","Map","preload","featureFileFd","fs","openSync","Error","preloadFeaturesRecursive","curTzData","quadPos","pos","len","geoJson","loadFeatures","Object","getOwnPropertyNames","forEach","value","lookup","_preCache","closeSync","fd","buf","Buffer","alloc","readSync","bytesRead","data","Pbf","decode","lat","originalLon","isNaN","map","zone","pt","point","quadData","top","bottom","midLat","midLon","nextQuad","getTimezoneAtSea","timezonesContainingPoint","features","inside","properties","idx","timezones"],"mappings":"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"}