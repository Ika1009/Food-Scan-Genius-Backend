{"version":3,"file":"geo-tz.modern.mjs","sources":["../src/oceanUtils.ts","../src/find.ts"],"sourcesContent":["type OceanZone = {\n  left: number\n  right: number\n  tzid: string\n}\n\nexport const oceanZones: OceanZone[] = [\n  { tzid: 'Etc/GMT-12', left: 172.5, right: 180 },\n  { tzid: 'Etc/GMT-11', left: 157.5, right: 172.5 },\n  { tzid: 'Etc/GMT-10', left: 142.5, right: 157.5 },\n  { tzid: 'Etc/GMT-9', left: 127.5, right: 142.5 },\n  { tzid: 'Etc/GMT-8', left: 112.5, right: 127.5 },\n  { tzid: 'Etc/GMT-7', left: 97.5, right: 112.5 },\n  { tzid: 'Etc/GMT-6', left: 82.5, right: 97.5 },\n  { tzid: 'Etc/GMT-5', left: 67.5, right: 82.5 },\n  { tzid: 'Etc/GMT-4', left: 52.5, right: 67.5 },\n  { tzid: 'Etc/GMT-3', left: 37.5, right: 52.5 },\n  { tzid: 'Etc/GMT-2', left: 22.5, right: 37.5 },\n  { tzid: 'Etc/GMT-1', left: 7.5, right: 22.5 },\n  { tzid: 'Etc/GMT', left: -7.5, right: 7.5 },\n  { tzid: 'Etc/GMT+1', left: -22.5, right: -7.5 },\n  { tzid: 'Etc/GMT+2', left: -37.5, right: -22.5 },\n  { tzid: 'Etc/GMT+3', left: -52.5, right: -37.5 },\n  { tzid: 'Etc/GMT+4', left: -67.5, right: -52.5 },\n  { tzid: 'Etc/GMT+5', left: -82.5, right: -67.5 },\n  { tzid: 'Etc/GMT+6', left: -97.5, right: -82.5 },\n  { tzid: 'Etc/GMT+7', left: -112.5, right: -97.5 },\n  { tzid: 'Etc/GMT+8', left: -127.5, right: -112.5 },\n  { tzid: 'Etc/GMT+9', left: -142.5, right: -127.5 },\n  { tzid: 'Etc/GMT+10', left: -157.5, right: -142.5 },\n  { tzid: 'Etc/GMT+11', left: -172.5, right: -157.5 },\n  { tzid: 'Etc/GMT+12', left: -180, right: -172.5 },\n]\n\n/**\n * Find the Etc/GMT* timezone name(s) corresponding to the given longitue.\n *\n * @param lon The longitude to analyze\n * @returns An array of strings of TZIDs\n */\nexport function getTimezoneAtSea(lon: number): string[] {\n  // coordinates along the 180 longitude should return two zones\n  if (lon === -180 || lon === 180) {\n    return ['Etc/GMT+12', 'Etc/GMT-12']\n  }\n  const tzs = []\n  for (let i = 0; i < oceanZones.length; i++) {\n    const z = oceanZones[i]\n    if (z.left <= lon && z.right >= lon) {\n      tzs.push(z.tzid)\n    } else if (z.right < lon) {\n      break\n    }\n  }\n  return tzs\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { decode } from 'geobuf'\nimport inside from '@turf/boolean-point-in-polygon'\nimport { point } from '@turf/helpers'\nimport Pbf from 'pbf'\n\nimport { getTimezoneAtSea, oceanZones } from './oceanUtils'\n\nconst tzData = require('../data/index.json')\n\nconst FEATURE_FILE_PATH = path.join(__dirname, '..', 'data', 'geo.dat')\nlet featureCache\n\ntype CacheOptions = {\n  /**\n   * If set to true, all features will be loaded into memory to shorten future lookup\n   * times.\n   */\n  preload?: boolean\n  /**\n   * Must be a map-like object with a `get` and `set` function.\n   */\n  store?: any\n}\n\n/**\n * Set caching behavior.\n *\n * @param {CacheOptions} options cachine options.\n */\nfunction cacheLevel(options?: CacheOptions) {\n  if (\n    options &&\n    options.store &&\n    typeof options.store.get === 'function' &&\n    typeof options.store.set === 'function'\n  ) {\n    featureCache = options.store\n  } else {\n    featureCache = new Map()\n  }\n  if (options && options.preload) {\n    const featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n\n    _preCache(featureFileFd)\n\n    fs.closeSync(featureFileFd)\n  }\n}\n\ncacheLevel()\n\n/**\n * A function that will load all features into an unexpiring cache\n *\n * @param {number} featureFileFd\n * @returns {void}\n */\nfunction _preCache(featureFileFd: number) {\n  // shoutout to github user @magwo for an initial version of this recursive function\n  function preloadFeaturesRecursive(curTzData, quadPos: string) {\n    if (curTzData.pos >= 0 && curTzData.len) {\n      const geoJson = loadFeatures(\n        quadPos,\n        curTzData.pos,\n        curTzData.len,\n        featureFileFd\n      )\n      featureCache.set(quadPos, geoJson)\n    } else if (typeof curTzData === 'object') {\n      Object.getOwnPropertyNames(curTzData).forEach(function (value) {\n        preloadFeaturesRecursive(curTzData[value], quadPos + value)\n      })\n    }\n  }\n  preloadFeaturesRecursive(tzData.lookup, '')\n}\n\n/**\n * Load features from geo.dat at offset pos with length len.\n * Optionally accept a file descriptor\n *\n * @param quadPos\n * @param pos\n * @param len\n * @param fd\n * @returns the GeoJSON features in within the given quad region as defined in the\n *  feature file data.\n */\nfunction loadFeatures(\n  quadPos: string,\n  pos: number,\n  len: number,\n  fd: number = -1\n) {\n  let featureFileFd = fd\n  if (featureFileFd < 0) {\n    featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n  }\n\n  // exact boundaries saved in file\n  // parse geojson for exact boundaries\n  const buf = Buffer.alloc(len)\n  const bytesRead = fs.readSync(featureFileFd, buf, 0, len, pos)\n\n  // close featureFileFd if we opened it\n  if (fd < 0) {\n    fs.closeSync(featureFileFd)\n  }\n\n  if (bytesRead < len) {\n    throw new Error(\n      `tried to read ${len} bytes from geo.dat but only got ${bytesRead} bytes`\n    )\n  }\n\n  const data = new Pbf(buf)\n  return decode(data)\n}\n\n/**\n * Find the timezone ID(s) at the given GPS coordinates.\n *\n * @param lat latitude (must be >= -90 and <=90)\n * @param lon longitue (must be >= -180 and <=180)\n * @returns An array of string of TZIDs at the given coordinate.\n */\nexport function find(lat: number, lon: number): string[] {\n  const originalLon = lon\n\n  let err\n\n  // validate latitude\n  if (isNaN(lat) || lat > 90 || lat < -90) {\n    err = new Error('Invalid latitude: ' + lat)\n    throw err\n  }\n\n  // validate longitude\n  if (isNaN(lon) || lon > 180 || lon < -180) {\n    err = new Error('Invalid longitude: ' + lon)\n    throw err\n  }\n\n  // North Pole should return all ocean zones\n  if (lat === 90) {\n    return oceanZones.map((zone) => zone.tzid)\n  }\n\n  // fix edges of the world\n  if (lat >= 89.9999) {\n    lat = 89.9999\n  } else if (lat <= -89.9999) {\n    lat = -89.9999\n  }\n\n  if (lon >= 179.9999) {\n    lon = 179.9999\n  } else if (lon <= -179.9999) {\n    lon = -179.9999\n  }\n\n  const pt = point([lon, lat])\n  const quadData = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0,\n  }\n  let quadPos = ''\n  let curTzData = tzData.lookup\n\n  while (true) {\n    // calculate next quadtree position\n    let nextQuad\n    if (lat >= quadData.midLat && lon >= quadData.midLon) {\n      nextQuad = 'a'\n      quadData.bottom = quadData.midLat\n      quadData.left = quadData.midLon\n    } else if (lat >= quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'b'\n      quadData.bottom = quadData.midLat\n      quadData.right = quadData.midLon\n    } else if (lat < quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'c'\n      quadData.top = quadData.midLat\n      quadData.right = quadData.midLon\n    } else {\n      nextQuad = 'd'\n      quadData.top = quadData.midLat\n      quadData.left = quadData.midLon\n    }\n\n    // console.log(nextQuad)\n    curTzData = curTzData[nextQuad]\n    // console.log()\n    quadPos += nextQuad\n\n    // analyze result of current depth\n    if (!curTzData) {\n      // no timezone in this quad, therefore must be timezone at sea\n      return getTimezoneAtSea(originalLon)\n    } else if (curTzData.pos >= 0 && curTzData.len) {\n      // get exact boundaries\n      let geoJson = featureCache.get(quadPos)\n      if (!geoJson) {\n        geoJson = loadFeatures(quadPos, curTzData.pos, curTzData.len)\n        featureCache.set(quadPos, geoJson)\n      }\n\n      const timezonesContainingPoint = []\n\n      for (let i = 0; i < geoJson.features.length; i++) {\n        if (inside(pt, geoJson.features[i])) {\n          timezonesContainingPoint.push(geoJson.features[i].properties.tzid)\n        }\n      }\n\n      // if at least one timezone contained the point, return those timezones,\n      // otherwise must be timezone at sea\n      return timezonesContainingPoint.length > 0\n        ? timezonesContainingPoint\n        : getTimezoneAtSea(originalLon)\n    } else if (curTzData.length > 0) {\n      // exact match found\n      return curTzData.map((idx) => tzData.timezones[idx])\n    } else if (typeof curTzData !== 'object') {\n      // not another nested quad index, throw error\n      err = new Error('Unexpected data type')\n      throw err\n    }\n\n    // calculate next quadtree depth data\n    quadData.midLat = (quadData.top + quadData.bottom) / 2\n    quadData.midLon = (quadData.left + quadData.right) / 2\n  }\n}\n\nexport { cacheLevel as setCache }\n\n/**\n * Load all features into memory to speed up future lookups.\n */\nexport function preCache() {\n  cacheLevel({ preload: true })\n}\n"],"names":["oceanZones","tzid","left","right","lon","tzs","i","length","z","push","tzData","require","FEATURE_FILE_PATH","path","join","__dirname","featureCache","cacheLevel","options","store","get","set","Map","preload","featureFileFd","fs","openSync","Error","preloadFeaturesRecursive","curTzData","quadPos","pos","len","geoJson","loadFeatures","Object","getOwnPropertyNames","forEach","value","lookup","_preCache","closeSync","fd","buf","Buffer","alloc","bytesRead","readSync","data","Pbf","decode","find","lat","originalLon","isNaN","err","map","zone","pt","point","quadData","top","bottom","midLat","midLon","nextQuad","getTimezoneAtSea","timezonesContainingPoint","features","inside","properties","idx","timezones","preCache"],"mappings":"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"}